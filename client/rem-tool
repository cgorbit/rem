#!/usr/bin/env python
import time
import optparse
import ConfigParser
import json

import remclient

class ICommander(object):
    def __init__(self, opt, action):
        self.type = action
        self.options = opt

    def __enter__(self):
        self.conn = remclient.Connector(self.options.url, conn_retries=2, verbose=True)
        self.conn.__enter__()
        return self

    def __exit__(self, *args):
        return self.conn.__exit__(*args)


def print_pck_info(pck, extended=False):
    workTime = pck.GetWorkingTime()
    hd = "packet '%s':" % pck.pck_id
    last_sandbox_task_id = getattr(pck, 'last_sandbox_task_id', None)
    print "%s\tname=%s,state=%s;wait=%r,priority=%s;working_time=%s;result_tag=%s;last_update='%s';notify_emails=%s;is_sandbox=%s;last_sandbox_task_id=%s,labels=%s" \
        % (hd, pck.name, pck.state, 
           pck.wait, pck.priority, workTime, pck.result_tag, 
           time.strftime("%Y/%m/%d-%H:%M:%S", time.localtime(pck.history[-1][1]) if pck.history else "none"),
           getattr(pck, 'notify_emails', None),
           getattr(pck, 'is_sandbox', False),
           last_sandbox_task_id,
           getattr(pck, 'labels', []) or [],
          )

    for job in pck.jobs:
        if job.state == "working": print "%sexec_shell=%s" % (" " * len(hd), job.shell)

    if extended:
        last_error = getattr(pck, 'last_global_error', None)
        if last_error:
            print "\nError: %s" % last_error

        resolved_releases = getattr(pck, 'resolved_releases', None)
        if resolved_releases:
            print "\nResolved resources:"
            for descr in sorted(resolved_releases.keys()):
                print "\t%s: %s" % (descr, resolved_releases[descr])

        if last_sandbox_task_id is not None:
            print '\nSandbox url: https://sandbox.yandex-team.ru/task/%d/view' % last_sandbox_task_id

        print ''
        for status, tstamp in pck.history:
            print "\t[%s] %s" % (time.ctime(tstamp), status)

        print ''
        for job in pck.jobs:
            print "[SUBJOB %s] id: %s,\tshell: %s" % (getattr(job, 'desc', ''), getattr(job, 'id', None), job.shell)
            if not getattr(job, 'wait_jobs', None):
                print job.state
            else:
                print "%s (waiting for jobs: %s)" % (job.state, ', '.join(str(j.id) for j in job.wait_jobs))
            print "\n".join(i.data.replace("\n", "\n\t") for i in job.results)


class CommandExecutionError(Exception): pass


class ListCommander(ICommander):
    def __call__(self):
        if self.options.queue:
            q = self.conn.Queue(self.options.queue)
            pckList = q.ListPackets(self.options.filter,
                                    self.options.name,
                                    self.options.prefix,
                                    self.options.min_mtime,
                                    self.options.max_mtime,
                                    self.options.labels)
            pckList = remclient.JobPacketInfo.multiupdate(pckList)
            for pck in pckList:
                print_pck_info(pck)
        elif self.options.list_tags:
            for tag, value in sorted(self.conn.ListObjects("tags", self.options.name, self.options.prefix)):
                print ("+" if value else "-"), tag
        elif self.options.list_all_tags:
            for tag, value in sorted(self.conn.ListObjects("tags", self.options.name, self.options.prefix, False)):
                print ("+" if value else "-"), tag
        else:
            for q, q_stat in self.conn.ListObjects("queues", self.options.name, self.options.prefix):
                print "queue '%s':\t\t%r" % (q, q_stat)


class TagManipCommander(ICommander):
    def __call__(self):
        tagname = self.options.tag
        tag = self.conn.Tag(tagname)
        if self.type == "set":
            tag.Set()
        elif self.type == "unset":
            tag.Unset()
        elif self.type == "reset":
            tag.Reset()


class LifeCommander(ICommander):
    def __call__(self):
        if self.options.packet:
            object = self.conn.PacketInfo(self.options.packet)
        elif self.options.queue:
            object = self.conn.Queue(self.options.queue)
        else:
            raise CommandExecutionError("unknown target for command: %s" % self.type)

        if self.type == "suspend":
            object.Suspend()
        elif self.type == "stop":
            if not isinstance(object, remclient.JobPacketInfo):
                raise CommandExecutionError("only packets may be stopped")
            object.Stop()
        elif self.type == "resume":
            object.Resume()
        elif self.type == "restart":
            if not isinstance(object, remclient.JobPacketInfo):
                raise CommandExecutionError("only packets may be restarted")
            if object.state == 'SUCCESSFULL':
                object.Restart()
            else:
                object.RestartFromErrors()
        elif self.type == "retry":
            if not isinstance(object, remclient.Queue):
                raise CommandExecutionError("retry is only for queue")
            for pack in object.ListPackets("errored"):
                pack.RestartFromErrors()
        elif self.type == "delete":
            if isinstance(object, remclient.Queue):
                self.delete_queue(object, self.conn.GetURL())
            else:
                object.Delete()
        else:
            raise CommandExecutionError("unknown command: %s" % self.type)

    @staticmethod
    def delete_queue(queue, uri):
        pause = 3
        print """\
WARNING!
Going to delete queue "{}" from "{}" in {} seconds:
- stop all packets;
- delete all packets;
- delete queue itself.
""".format(queue.name, uri, pause)
        time.sleep(pause)

        queue.Suspend()
        packets = queue.ListPackets("all")
        for pack in packets:
            if pack.state not in ['ERROR', 'SUCCESSFULL', 'HISTORIED']:
                pack.Stop()
        for pack in packets:
            pack.Delete()
        queue.Delete()
        print 'Queue {} deleted.'.format(queue.name)

class StatusCommander(ICommander):
    def __call__(self):
        if self.options.queue:
            q = self.conn.Queue(self.options.queue)
            print "queue '%s':\t%r" % (self.options.queue, q.Status())
        if self.options.packet:
            pck = self.conn.PacketInfo(self.options.packet)
            print_pck_info(pck, extended=True)
        if self.options.tag:
            tag = self.conn.Tag(self.options.tag)
            print "tag %s value: %s" % (tag.name, tag.Check())


class UpdateCommander(ICommander):
    def __call__(self):
        if self.options.packet and self.options.files:
            pck_id = self.options.packet
            files = self.options.files
            pck = self.conn.PacketInfo(pck_id)
            pck.AddFiles(files)
        elif self.options.queue and self.options.working_limit:
            queue = self.conn.Queue(self.options.queue)
            queue.ChangeWorkingLimit(self.options.working_limit)
        else:
            raise CommandExecutionError("not enough parameters for update command")


class MoveCommander(ICommander):
    def __call__(self):
        pck_id = self.options.packet
        src_q, dest_q = self.options.from_to.split(":")
        if not (pck_id and src_q and dest_q):
            raise CommandExecutionError("can't move packet %r from \"%s\" to\"%s\"" % (pck_id, src_q, dest_q))
        pck = self.conn.PacketInfo(pck_id)
        pck.MoveToQueue(src_q, dest_q)


_DISP_COMMANDS = {
    "list":     (ListCommander,     "list rem objects (queues (by default), packets (if --queue set) or tags(if --tags set))"),
    "status":   (StatusCommander,   "print object status (--queue, --packet or --tag have to been set)"),
    "update":   (UpdateCommander,   "update packet data (with --packet and --file) or working limit for queue (with --queue and --working-limit)"),
    "move":     (MoveCommander,     "move packet between queues, see --relloc-path"),
    "suspend":  (LifeCommander,     "suspend object execution (--queue or --packet have to been set)"),
    "resume":   (LifeCommander,     "resume object execution  (--queue or --packet have to been set)"),
    "retry":    (LifeCommander,     "restart all errored packets of queue (requires --queue), see also restart action"),
    "restart":  (LifeCommander,     "restart errored packet (requires --packet), see also retry action"),
    "delete":   (LifeCommander,     "delete object (requires -q (--queue) or -p (--packet))"),
    "stop":     (LifeCommander,     "stop packet execution (suspend and kill all jobs, --packet have to been set)"),
    "set":      (TagManipCommander, "set tag (--tag have to been set)"),
    "unset":    (TagManipCommander, "unset tag (--tag have to been set)"),
    "reset":    (TagManipCommander, "reset tag (--tag have to been set)"),
}

def rem_url_from_cfg(path):
    cfg = ConfigParser.SafeConfigParser()
    cfg.read(path)
    return 'http://{}:{}/'.format(cfg.get('server', 'network_hostname'), cfg.get('server', 'port'))

def parse_args():
    descr = "%prog [options] action\npossible actions:"
    for action in sorted(_DISP_COMMANDS.keys()):
        descr += '\n    {:8} - {}'.format(action, _DISP_COMMANDS[action][1])

    parser = optparse.OptionParser(descr)
    parser.add_option("-u", "--url", help="set REM server url")
    parser.add_option('--rem-cfg', help='pathname of REM configuration file')
    parser.add_option("-q", "--queue", dest="queue", help="set target queue name")
    parser.add_option("-p", "--packet", dest="packet", help="set target packet id")
    parser.add_option("-f", "--file", dest="files", action="append", default=[], help="set file for packet updating")
    parser.add_option("-t", "--tag", dest="tag", help="set tag name")
    parser.add_option("--tags", dest="list_tags", action="store_const", const=True, help="list tags, makes sense only with list action")
    parser.add_option("--alltags", dest="list_all_tags", action="store_const", const=True, help="list tags (including tags not in memory), makes sense only with list action")
    parser.add_option("-F", "--filter", dest="filter", default="all", help="set targets filter (for listing packets in queue")
    parser.add_option("-N", "--name", dest="name", help="name regexp for filtering list of tags or packets")
    parser.add_option("-P", "--prefix", dest="prefix", help="name prefix for filtering list of tags or packets")
    parser.add_option("--min-mtime")
    parser.add_option("--max-mtime")
    parser.add_option("-R", "--relloc-path", dest="from_to", default=":", help="relocation PATH for moved packet (':'-splitted pair of queues)", metavar="PATH")
    parser.add_option("-W", "--working-limit", dest="working_limit", type="int", help="set working limit for queue")
    parser.add_option("-l", "--labels", dest="labels", action='append', help="")
    opt, args = parser.parse_args()

    if not args:
        parser.error('need action')
    if len(args) > 1:
        parser.error('only one action at a time')
    action = args[0]
    if not action in _DISP_COMMANDS:
        parser.error('unknown action "{}", use one of: {}'.format(action, ', '.join(sorted(_DISP_COMMANDS.keys()))))

    if opt.url:
        if opt.rem_cfg:
            parser.error("options -u (--url) and --rem-cfg are mutually exclusive")
    else:
        if opt.rem_cfg:
            opt.url = rem_url_from_cfg(opt.rem_cfg)
        else:
            """
            Leave intact for production.
            For local/testing REM you could use one of "opt.url =" lines in
            order to shorten command line of rem-tool call.
            """
            parser.error('specify -u (--url) or --rem-cfg')
            # opt.url = 'http://localhost:8104/'
            # opt.url = rem_url_from_cfg('./rem.cfg')

    return opt, action

def main():
    opt, action = parse_args()
    with _DISP_COMMANDS[action][0](opt, action) as commander:
        commander()


if __name__ == "__main__":
    main()
